# 04-call-chain.md - 业务调用链分析

本文档详细分析Redis NUMA改造后的完整业务调用链，从应用层到系统层的完整数据流。

---

## 整体架构

```
┌─────────────────────────────────────────────────────────────────┐
│                        Application Layer                         │
│  ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐   │
│  │  String │ │  List   │ │  Hash   │ │  Set    │ │ ZSet    │   │
│  │ t_string│ │ t_list  │ │ t_hash  │ t_set    │ │ t_zset  │   │
│  └────┬────┘ └────┬────┘ └────┬────┘ └────┬────┘ └────┬────┘   │
│       │           │           │           │           │        │
│       └───────────┴───────────┴─────┬─────┴───────────┘        │
│                                     │                          │
│                              ┌──────┴──────┐                   │
│                              │    Object   │                   │
│                              │   object.c  │                   │
│                              └──────┬──────┘                   │
└─────────────────────────────────────┼───────────────────────────┘
                                      │ robj, sds
                                      ▼
┌─────────────────────────────────────────────────────────────────┐
│                     Memory Allocation Layer                      │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │                     zmalloc.c / zmalloc.h                  │  │
│  │  ┌─────────────┐  ┌─────────────┐  ┌───────────────────┐  │  │
│  │  │ zmalloc()   │  │ zcalloc()   │  │ zrealloc()        │  │  │
│  │  │ zfree()     │  │ zmalloc_    │  │ zmalloc_usable()  │  │  │
│  │  │ zmalloc_    │  │   size()    │  │                   │  │  │
│  │  │   _size()   │  │             │  │                   │  │  │
│  │  └──────┬──────┘  └──────┬──────┘  └─────────┬─────────┘  │  │
│  │         │                │                   │            │  │
│  │         └────────────────┼───────────────────┘            │  │
│  │                          │                                │  │
│  │         ┌────────────────┴────────────────┐               │  │
│  │         │    numa_alloc_with_size()        │               │  │
│  │         │    numa_free_with_size()         │               │  │
│  │         └────────────────┬────────────────┘               │  │
│  └──────────────────────────┼────────────────────────────────┘  │
│                             │                                    │
│              ┌──────────────┼──────────────┐                     │
│              │              │              │                     │
│              ▼              ▼              ▼                     │
│  ┌─────────────────┐ ┌─────────────┐ ┌─────────────────┐        │
│  │   numa_pool.c   │ │ numa_migrate│ │  numa_alloc_    │        │
│  │   (内存池模块)   │ │    .c       │ │   onnode()      │        │
│  │                 │ │  (迁移模块)  │ │  (直接分配)      │        │
│  │  numa_pool_     │ │             │ │                 │        │
│  │   alloc()       │ │ numa_migrate│ │                 │        │
│  │  numa_pool_     │ │   _memory() │ │                 │        │
│  │   free()        │ │             │ │                 │        │
│  └────────┬────────┘ └──────┬──────┘ └────────┬────────┘        │
└───────────┼─────────────────┼─────────────────┼─────────────────┘
            │                 │                 │
            └─────────────────┴─────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                        System Layer                              │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │                        libnuma.so                          │  │
│  │  numa_alloc_onnode()  numa_free()  numa_available()       │  │
│  │  numa_max_node()      numa_node_of_cpu()  numa_distance() │  │
│  └───────────────────────────────────────────────────────────┘  │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │                    libc / system calls                     │  │
│  │  malloc()  free()  memcpy()  sched_getcpu()               │  │
│  └───────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
```

---

## 场景1: SET命令执行流程

```
客户端: SET mykey "Hello, NUMA!"

┌─────────────────────────────────────────────────────────────┐
│  1. 网络层处理                                                │
│  networking.c: readQueryFromClient()                        │
│  └──► 解析RESP协议                                            │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  2. 命令查找与执行                                            │
│  server.c: processCommand()                                 │
│  └──► lookupCommand("set")                                  │
│  └──► call(c, CMD_CALL_FULL)                                │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  3. SET命令实现                                               │
│  t_string.c: setCommand()                                   │
│  └──► setGenericCommand()                                   │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  4. 创建Redis对象                                             │
│  object.c: createStringObject()                             │
│  └──► sdsnewlen(ptr, len)                                   │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  5. SDS分配（第一次内存分配）                                  │
│  sds.c: sdsnewlen()                                         │
│  └──► s_malloc(size + hdrlen + 1)                           │
│       └──► zmalloc()                                        │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  6. NUMA内存分配                                              │
│  zmalloc.c: zmalloc(100)                                    │
│  └──► ztrymalloc_usable(100, NULL)                          │
│       └──► numa_alloc_with_size(100)                        │
│           ├──► numa_pool_alloc(116, current_node, ...)      │
│           │   └──► 从64KB chunk分配256字节                   │
│           │   └──► from_pool = 1                            │
│           ├──► numa_init_prefix(raw_ptr, 100, 1)            │
│           └──► 返回 user_ptr (raw_ptr + 16)                 │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  7. 数据复制                                                  │
│  memcpy(sds_ptr, "Hello, NUMA!", 13)                        │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  8. 添加到数据库                                              │
│  db.c: setKey()                                             │
│  └──► dictAdd(db->dict, key, val)                           │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  9. 字典扩容（可能需要第二次分配）                             │
│  dict.c: dictAdd()                                          │
│  └──► _dictExpandIfNeeded()                                 │
│       └──► dictExpand()                                     │
│           └──► zcalloc() 或 zrealloc()                      │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  10. 返回响应                                                 │
│  addReply(c, shared.ok)                                     │
└─────────────────────────────────────────────────────────────┘
```

**内存分配统计（SET一个String）**:
- SDS对象: ~100字节数据 + 16字节PREFIX = 116字节（来自内存池）
- 字典节点: 取决于当前字典负载
- 总计: 通常200-500字节

---

## 场景2: GET命令执行流程

```
客户端: GET mykey

┌─────────────────────────────────────────────────────────────┐
│  1-3步与SET相同（网络层、命令查找）                            │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  4. GET命令实现                                               │
│  t_string.c: getCommand()                                   │
│  └──► lookupKeyRead()                                       │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  5. 查找键（无内存分配，仅读取）                               │
│  db.c: lookupKey()                                          │
│  └──► dictFind(db->dict, key)                               │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  6. 获取值对象                                                │
│  读取robj.ptr（指向SDS的指针）                                 │
│  通过PREFIX获取size: zmalloc_size(robj.ptr)                 │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  7. 构建响应（可能需要分配）                                   │
│  addReplyBulk()                                             │
│  └──► 构建RESP Bulk String响应                              │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  8. 发送响应                                                  │
│  writeToClient()                                            │
└─────────────────────────────────────────────────────────────┘
```

**内存访问统计（GET一个String）**:
- 读取SDS对象: 通过PREFIX获取size（内存访问）
- 无新内存分配（仅读取）
- 响应缓冲区: 使用连接输出缓冲区

---

## 场景3: 内存迁移流程

```
场景: 将key "mykey" 从Node 0迁移到Node 1

┌─────────────────────────────────────────────────────────────┐
│  1. 查找目标键                                                │
│  lookupKeyWrite()                                           │
│  └──► 获取robj指针                                           │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  2. 获取对象数据                                              │
│  根据robj类型获取数据指针和大小                                │
│  - String: robj.ptr (SDS)                                   │
│  - Hash: hash表中的多个对象                                   │
│  - List: quicklist节点                                        │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  3. 执行迁移（以String为例）                                   │
│  numa_migrate_memory(robj.ptr, size, 1)                     │
│  └──► 1. numa_zmalloc_onnode(size, 1)                       │
│       └──► numa_alloc_onnode()                              │
│           └──► 在Node 1分配物理内存                           │
│  └──► 2. memcpy(new_ptr, old_ptr, size)                     │
│       └──► 复制数据到新位置                                   │
│  └──► 3. zfree(old_ptr)                                     │
│       └──► numa_free_with_size()                            │
│           └──► 释放Node 0的内存                               │
│  └──► 4. 返回new_ptr                                        │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  4. 更新对象指针                                              │
│  robj.ptr = new_ptr                                         │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  5. 验证迁移结果                                              │
│  可选: 读取数据验证完整性                                      │
└─────────────────────────────────────────────────────────────┘
```

**迁移性能**:
- 1KB数据: ~3-5 μs
- 10KB数据: ~10-15 μs
- 1MB数据: ~1-2 ms

---

## 场景4: 内存释放流程

```
场景: DEL mykey 或内存淘汰

┌─────────────────────────────────────────────────────────────┐
│  1. 查找并删除键                                              │
│  db.c: dbAsyncDelete() 或 dbSyncDelete()                    │
│  └──► dictDelete(db->dict, key)                             │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  2. 获取值对象                                                │
│  从字典中获取robj                                            │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  3. 释放对象                                                  │
│  decrRefCount(robj)                                         │
│  └──► 引用计数减到0时调用freeStringObject()                 │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  4. 释放SDS内存                                               │
│  sdsfree(sds_ptr)                                           │
│  └──► s_free()                                              │
│       └──► zfree(sds_ptr)                                   │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  5. NUMA内存释放                                              │
│  zmalloc.c: zfree(user_ptr)                                 │
│  └──► numa_free_with_size(user_ptr)                         │
│       ├──► numa_get_prefix(user_ptr)                        │
│       │   └──► 读取PREFIX: size=100, from_pool=1            │
│       ├──► update_zmalloc_stat_free(116)                    │
│       └──► numa_pool_free(raw_ptr, 116, 1)                  │
│           └──► from_pool=1，不释放（池内存统一清理）          │
└─────────────────────────────────────────────────────────────┘
```

**释放策略**:
- 池分配内存: 不单独释放，程序结束时统一清理
- 直接分配内存: 调用numa_free()立即归还系统

---

## 内存分配热点分析

### 高频分配场景（来自内存池）

| 场景 | 分配大小 | 来源 | 频率 |
|------|---------|------|------|
| SDS字符串 | 16-512B | numa_pool | 极高 |
| robj对象 | ~32B | numa_pool | 极高 |
| dictEntry | ~24B | numa_pool | 高 |
| 客户端缓冲区 | 可变 | 直接分配 | 中 |
| RDB加载 | 大块 | 直接分配 | 低 |

### 内存池命中率

- 小对象（≤512B）: >95%
- 中对象（512B-2KB）: ~50%
- 大对象（>2KB）: 0%（直接分配）

---

## 性能优化点

### 1. 内存池优化
- 64KB chunk大小平衡命中率和碎片
- 8级大小分类覆盖主要场景
- per-pool锁减少竞争

### 2. PREFIX优化
- 16字节对齐，CPU缓存友好
- 内联函数快速访问
- 复用padding存储元数据（未来）

### 3. 线程优化
- TLS缓存当前节点，减少系统调用
- 线程亲和性绑定（可选）

---

## 调试与监控

### 统计信息获取

```c
/* 内存池统计 */
numa_pool_stats_t pool_stats;
numa_pool_get_stats(node_id, &pool_stats);

/* 迁移统计 */
numa_migrate_stats_t migrate_stats;
numa_migrate_get_stats(&migrate_stats);

/* zmalloc统计 */
size_t used_memory = zmalloc_used_memory();
```

### 日志输出

```c
/* 在关键位置添加日志 */
serverLog(LL_NOTICE, "NUMA allocation on node %d, size %zu", 
          numa_get_current_node(), size);
```
