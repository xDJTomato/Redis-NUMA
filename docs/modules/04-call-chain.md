# 04-call-chain.md - 业务调用链分析

本文档详细分析Redis NUMA改造后的完整业务调用链，从应用层到系统层的完整数据流。

---

## 整体架构

```
┌─────────────────────────────────────────────────────────────────┐
│                        Application Layer                         │
│  ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐   │
│  │  String │ │  List   │ │  Hash   │ │  Set    │ │ ZSet    │   │
│  │ t_string│ │ t_list  │ │ t_hash  │ t_set    │ │ t_zset  │   │
│  └────┬────┘ └────┬────┘ └────┬────┘ └────┬────┘ └────┬────┘   │
│       │           │           │           │           │        │
│       └───────────┴───────────┴─────┬─────┴───────────┘        │
│                                     │                          │
│                              ┌──────┴──────┐                   │
│                              │    Object   │                   │
│                              │   object.c  │                   │
│                              └──────┬──────┘                   │
└─────────────────────────────────────┼───────────────────────────┘
                                      │ robj, sds
                                      ▼
┌─────────────────────────────────────────────────────────────────┐
│                     Memory Allocation Layer                      │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │                     zmalloc.c / zmalloc.h                  │  │
│  │  ┌─────────────┐  ┌─────────────┐  ┌───────────────────┐  │  │
│  │  │ zmalloc()   │  │ zcalloc()   │  │ zrealloc()        │  │  │
│  │  │ zfree()     │  │ zmalloc_    │  │ zmalloc_usable()  │  │  │
│  │  │ zmalloc_    │  │   size()    │  │                   │  │  │
│  │  │   _size()   │  │             │  │                   │  │  │
│  │  └──────┬──────┘  └──────┬──────┘  └─────────┬─────────┘  │  │
│  │         │                │                   │            │  │
│  │         └────────────────┼───────────────────┘            │  │
│  │                          │                                │  │
│  │         ┌────────────────┴────────────────┐               │  │
│  │         │    numa_alloc_with_size()        │               │  │
│  │         │    numa_free_with_size()         │               │  │
│  │         └────────────────┬────────────────┘               │  │
│  └──────────────────────────┼────────────────────────────────┘  │
│                             │                                    │
│              ┌──────────────┼──────────────┐                     │
│              │              │              │                     │
│              ▼              ▼              ▼                     │
│  ┌─────────────────┐ ┌─────────────┐ ┌─────────────────┐        │
│  │   numa_pool.c   │ │ numa_slab.c │ │  numa_alloc_    │        │
│  │   (内存池模块)   │ │ (Slab模块)  │ │   onnode()      │        │
│  │                 │ │  P2优化      │ │  (直接分配)      │        │
│  │  numa_pool_     │ │             │ │                 │        │
│  │   alloc()       │ │ numa_slab_  │ │                 │        │
│  │  numa_pool_     │ │   alloc()   │ │                 │        │
│  │   free()        │ │ numa_slab_  │ │                 │        │
│  │                 │ │   free()    │ │                 │        │
│  └────────┬────────┘ └──────┬──────┘ └────────┬────────┘        │
└───────────┼─────────────────┼─────────────────┼─────────────────┘
            │                 │                 │
            └─────────────────┴─────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                     Configuration Layer                         │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │              numa_configurable_strategy.c                 │  │
│  │  ┌─────────────────┐  ┌─────────────────┐                │  │
│  │  │ 策略选择逻辑      │  │ 运行时配置管理    │                │  │
│  │  │ select_best_node()│ │ config management │                │  │
│  │  └────────┬────────┘  └────────┬────────┘                │  │
│  │           │                    │                          │  │
│  │           ▼                    ▼                          │  │
│  │  ┌─────────────────┐  ┌─────────────────┐                │  │
│  │  │   6种分配策略     │  │ 负载均衡算法      │                │  │
│  │  │ - LOCAL_FIRST    │ │ - utilization    │                │  │
│  │  │ - INTERLEAVE     │ │   calculation    │                │  │
│  │  │ - ROUND_ROBIN    │ │ - rebalance      │                │  │
│  │  │ - WEIGHTED       │ │   triggering     │                │  │
│  │  │ - PRESSURE_AWARE │ │                  │                │  │
│  │  │ - CXL_OPTIMIZED  │ │                  │                │  │
│  │  └─────────────────┘  └─────────────────┘                │  │
│  └─────────────────────────────┬─────────────────────────────┘  │
│                                │                                  │
│  ┌─────────────────────────────┼─────────────────────────────┐   │
│  │        numa_config_command.c                              │   │
│  │  ┌─────────────────────────────────────────────────────┐  │   │
│  │  │              NUMACONFIG Redis命令接口                │  │   │
│  │  │  ┌─────────────┐ ┌─────────────┐ ┌──────────────┐   │  │   │
│  │  │  │ GET子命令    │ │ SET子命令    │ │ STATS子命令   │   │  │   │
│  │  │  │ - 查询配置    │ │ - 修改配置    │ │ - 统计信息    │   │  │   │
│  │  │  │ - 状态报告    │ │ - 策略切换    │ │ - 负载监控    │   │  │   │
│  │  │  └─────────────┘ └─────────────┘ └──────────────┘   │  │   │
│  │  └─────────────────────────────────────────────────────┘  │   │
│  └───────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                        System Layer                              │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │                        libnuma.so                          │  │
│  │  numa_alloc_onnode()  numa_free()  numa_available()       │  │
│  │  numa_max_node()      numa_node_of_cpu()  numa_distance() │  │
│  └───────────────────────────────────────────────────────────┘  │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │                    libc / system calls                     │  │
│  │  malloc()  free()  memcpy()  sched_getcpu()               │  │
│  └───────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
```

---

## 场景1: SET命令执行流程

```
客户端: SET mykey "Hello, NUMA!"

┌─────────────────────────────────────────────────────────────┐
│  1. 网络层处理                                                │
│  networking.c: readQueryFromClient()                        │
│  └──► 解析RESP协议                                            │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  2. 命令查找与执行                                            │
│  server.c: processCommand()                                 │
│  └──► lookupCommand("set")                                  │
│  └──► call(c, CMD_CALL_FULL)                                │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  3. SET命令实现                                               │
│  t_string.c: setCommand()                                   │
│  └──► setGenericCommand()                                   │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  4. 创建Redis对象                                             │
│  object.c: createStringObject()                             │
│  └──► sdsnewlen(ptr, len)                                   │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  5. SDS分配（第一次内存分配）                                  │
│  sds.c: sdsnewlen()                                         │
│  └──► s_malloc(size + hdrlen + 1)                           │
│       └──► zmalloc()                                        │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  6. NUMA内存分配 (P2优化: Slab + Pool双路径)                  │
│  zmalloc.c: zmalloc(100)                                    │
│  └──► ztrymalloc_usable(100, NULL)                          │
│       └──► numa_alloc_with_size(100)                        │
│           ├──► 【P2优化】numa_slab_alloc(100, node, ...)     │
│           │   └──► 检查size <= SLAB_MAX_OBJECT_SIZE (128B)  │
│           │   └──► 从16KB slab分配对象 (O(1) bitmap)        │
│           │   └──► 返回slab内地址                           │
│           ├──► 【备选】numa_pool_alloc(116, current_node, ...)│
│           │   └──► 从256KB chunk分配 (O(1) bump pointer)    │
│           │   └──► from_pool = 1                            │
│           ├──► numa_init_prefix(raw_ptr, 100, 1, node)      │
│           │   └──► P2 fix: 记录node_id到PREFIX              │
│           └──► 返回 user_ptr (raw_ptr + 16)                 │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  7. 数据复制                                                  │
│  memcpy(sds_ptr, "Hello, NUMA!", 13)                        │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  8. 添加到数据库                                              │
│  db.c: setKey()                                             │
│  └──► dictAdd(db->dict, key, val)                           │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  9. 字典扩容（可能需要第二次分配）                             │
│  dict.c: dictAdd()                                          │
│  └──► _dictExpandIfNeeded()                                 │
│       └──► dictExpand()                                     │
│           └──► zcalloc() 或 zrealloc()                      │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  10. 返回响应                                                 │
│  addReply(c, shared.ok)                                     │
└─────────────────────────────────────────────────────────────┘
```

**内存分配统计（SET一个String）**:
- SDS对象: ~100字节数据 + 16字节PREFIX = 116字节（来自内存池）
- 字典节点: 取决于当前字典负载
- 总计: 通常200-500字节

---

## 场景2: GET命令执行流程

```
客户端: GET mykey

┌─────────────────────────────────────────────────────────────┐
│  1-3步与SET相同（网络层、命令查找）                            │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  4. GET命令实现                                               │
│  t_string.c: getCommand()                                   │
│  └──► lookupKeyRead()                                       │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  5. 查找键（无内存分配，仅读取）                               │
│  db.c: lookupKey()                                          │
│  └──► dictFind(db->dict, key)                               │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  6. 获取值对象                                                │
│  读取robj.ptr（指向SDS的指针）                                 │
│  通过PREFIX获取size: zmalloc_size(robj.ptr)                 │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  7. 构建响应（可能需要分配）                                   │
│  addReplyBulk()                                             │
│  └──► 构建RESP Bulk String响应                              │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  8. 发送响应                                                  │
│  writeToClient()                                            │
└─────────────────────────────────────────────────────────────┘
```

**内存访问统计（GET一个String）**:
- 读取SDS对象: 通过PREFIX获取size（内存访问）
- 无新内存分配（仅读取）
- 响应缓冲区: 使用连接输出缓冲区

---

## 场景3: Slab Allocator分配流程 (P2优化)

```
场景: 分配一个小对象（size <= 128B）

┌─────────────────────────────────────────────────────────────┐
│  1. 分配请求                                                  │
│  zmalloc(64)                                                │
│  └──► numa_alloc_with_size(64)                              │
│      └──► should_use_slab(64) = true (<=128B)               │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  2. Slab分配 (O(1)复杂度)                                     │
│  numa_slab_alloc(64, target_node, &alloc_size)              │
│  └──► 查找size class (64B → class_idx=5)                    │
│  └──► 获取node的slab class                                   │
│  └──► 检查partial_slabs链表                                  │
│       └──► 找到可用slab                                      │
│  └──► bitmap_find_and_set() [O(1)]                          │
│       └──► __builtin_ffs(~bitmap_word) - 1                  │
│       └──► __atomic_compare_exchange_n() 原子设置bit        │
│  └──► 计算对象地址: slab->memory + SLAB_HEADER_SIZE + offset│
│  └──► __atomic_sub_fetch(&slab->free_count, 1)             │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  3. 初始化PREFIX (P2 fix)                                     │
│  numa_init_prefix(raw_ptr, 64, 1, target_node)              │
│  └──► prefix->size = 64                                     │
│  └──► prefix->from_pool = 1                                 │
│  └──► prefix->node_id = target_node (关键修复)              │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  4. 返回用户指针                                              │
│  返回 raw_ptr + PREFIX_SIZE (16字节)                        │
└─────────────────────────────────────────────────────────────┘
```

**Slab分配特点**:
- **时间复杂度**: O(1) - bitmap查找 + 原子操作
- **空间效率**: 16KB slab可容纳约240个64B对象
- **无锁设计**: 使用原子操作，减少锁竞争
- **NUMA感知**: 每个节点独立slab池

---

## 场景4: Slab释放流程 (P2优化)

```
场景: 释放一个小对象（通过Slab分配）

┌─────────────────────────────────────────────────────────────┐
│  1. 释放请求                                                  │
│  zfree(user_ptr)                                            │
│  └──► numa_free_with_size(user_ptr)                         │
│      └──► prefix = numa_get_prefix(user_ptr)                │
│      └──► should_use_slab(prefix->size) = true              │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌──────────────────────────┬──────────────────────────────────┐
│  2. 获取正确节点 (P2 fix关键)                                 │
│  node_id = prefix->node_id  [从PREFIX读取，非round-robin]   │
│  └──► 确保在分配时的同一节点释放                              │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  3. O(1) Slab定位 (P2优化)                                    │
│  numa_slab_free(raw_ptr, total_size, node_id)               │
│  └──► ptr_addr = (uintptr_t)raw_ptr                         │
│  └──► slab_base = ptr_addr & ~(SLAB_SIZE - 1)  [页对齐]     │
│  └──► header = (numa_slab_header_t *)slab_base              │
│  └──► 验证 header->magic == SLAB_HEADER_MAGIC               │
│  └──► slab = header->slab  [O(1)获取slab指针]               │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  4. 释放对象                                                  │
│  bitmap_clear(slab->bitmap, obj_index)                      │
│  └──► __atomic_fetch_and() 原子清除bit                      │
│  └──► __atomic_fetch_add(&slab->free_count, 1)             │
│  └──► 检查是否需要移动slab链表 (full→partial→empty)         │
└─────────────────────────────────────────────────────────────┘
```

**Slab释放特点**:
- **O(1)定位**: 通过page对齐计算slab基地址，无需遍历链表
- **节点一致性**: 使用PREFIX中记录的node_id，避免内存泄漏
- **原子操作**: bitmap操作使用原子指令，线程安全

---

## 场景5: 内存迁移流程

```
场景: 将key "mykey" 从Node 0迁移到Node 1

┌─────────────────────────────────────────────────────────────┐
│  1. 查找目标键                                                │
│  lookupKeyWrite()                                           │
│  └──► 获取robj指针                                           │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  2. 获取对象数据                                              │
│  根据robj类型获取数据指针和大小                                │
│  - String: robj.ptr (SDS)                                   │
│  - Hash: hash表中的多个对象                                   │
│  - List: quicklist节点                                        │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  3. 执行迁移（以String为例）                                   │
│  numa_migrate_memory(robj.ptr, size, 1)                     │
│  └──► 1. numa_zmalloc_onnode(size, 1)                       │
│       └──► numa_alloc_onnode()                              │
│           └──► 在Node 1分配物理内存                           │
│  └──► 2. memcpy(new_ptr, old_ptr, size)                     │
│       └──► 复制数据到新位置                                   │
│  └──► 3. zfree(old_ptr)                                     │
│       └──► numa_free_with_size()                            │
│           └──► 释放Node 0的内存                               │
│  └──► 4. 返回new_ptr                                        │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  4. 更新对象指针                                              │
│  robj.ptr = new_ptr                                         │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  5. 验证迁移结果                                              │
│  可选: 读取数据验证完整性                                      │
└─────────────────────────────────────────────────────────────┘
```

**迁移性能**:
- 1KB数据: ~3-5 μs
- 10KB数据: ~10-15 μs
- 1MB数据: ~1-2 ms

---

## 场景4: 内存释放流程

```
场景: DEL mykey 或内存淘汰

┌─────────────────────────────────────────────────────────────┐
│  1. 查找并删除键                                              │
│  db.c: dbAsyncDelete() 或 dbSyncDelete()                    │
│  └──► dictDelete(db->dict, key)                             │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  2. 获取值对象                                                │
│  从字典中获取robj                                            │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  3. 释放对象                                                  │
│  decrRefCount(robj)                                         │
│  └──► 引用计数减到0时调用freeStringObject()                 │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  4. 释放SDS内存                                               │
│  sdsfree(sds_ptr)                                           │
│  └──► s_free()                                              │
│       └──► zfree(sds_ptr)                                   │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  5. NUMA内存释放                                              │
│  zmalloc.c: zfree(user_ptr)                                 │
│  └──► numa_free_with_size(user_ptr)                         │
│       ├──► numa_get_prefix(user_ptr)                        │
│       │   └──► 读取PREFIX: size=100, from_pool=1            │
│       ├──► update_zmalloc_stat_free(116)                    │
│       └──► numa_pool_free(raw_ptr, 116, 1)                  │
│           └──► from_pool=1，不释放（池内存统一清理）          │
└─────────────────────────────────────────────────────────────┘
```

**释放策略**:
- 池分配内存: 不单独释放，程序结束时统一清理
- 直接分配内存: 调用numa_free()立即归还系统

---

## 内存分配热点分析

### 高频分配场景（来自内存池）

| 场景 | 分配大小 | 来源 | 频率 |
|------|---------|------|------|
| SDS字符串 | 16-512B | numa_pool | 极高 |
| robj对象 | ~32B | numa_pool | 极高 |
| dictEntry | ~24B | numa_pool | 高 |
| 客户端缓冲区 | 可变 | 直接分配 | 中 |
| RDB加载 | 大块 | 直接分配 | 低 |

### 内存池命中率

- 小对象（≤512B）: >95%
- 中对象（512B-2KB）: ~50%
- 大对象（>2KB）: 0%（直接分配）

---

## 性能优化点

### 1. 内存池优化
- 64KB chunk大小平衡命中率和碎片
- 8级大小分类覆盖主要场景
- per-pool锁减少竞争

### 2. PREFIX优化
- 16字节对齐，CPU缓存友好
- 内联函数快速访问
- 复用padding存储元数据（未来）

### 3. 线程优化
- TLS缓存当前节点，减少系统调用
- 线程亲和性绑定（可选）

---

## 场景5: NUMACONFIG命令执行流程

```
客户端: NUMACONFIG GET

┌─────────────────────────────────────────────────────────────┐
│  1. 网络层处理                                                │
│  networking.c: readQueryFromClient()                        │
│  └──► 解析RESP协议: ["NUMACONFIG", "GET"]                     │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  2. 命令查找与执行                                            │
│  server.c: processCommand()                                 │
│  └──► lookupCommand("numaconfig")                           │
│  └──► call(c, CMD_CALL_FULL)                                │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  3. NUMACONFIG命令处理                                         │
│  numa_config_command.c: numaconfigCommand()                 │
│  └──► 获取子命令: "GET"                                      │
│  └──► 调用对应处理函数                                       │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  4. GET子命令实现                                             │
│  numa_config_command.c: 处理GET分支                          │
│  └──► numa_config_get_current()                             │
│       └──► 获取当前运行时配置                                 │
│  └──► 构建响应数组                                           │
│       ├──► addReplyArrayLen(c, 10)                          │
│       ├──► addReplyBulkCString(c, "strategy")                │
│       ├──► addReplyBulkCString(c, "interleaved")             │
│       └──► ... 其他配置项                                     │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  5. 返回响应                                                  │
│  networking.c: writeToClient()                              │
│  └──► 发送RESP数组响应给客户端                                │
└─────────────────────────────────────────────────────────────┘
```

**配置查询流程**:
- 无内存分配（仅读取配置）
- 响应构建使用现代API: addReplyArrayLen()
- 配置信息来自全局运行时状态

---

## 场景6: 动态策略配置流程

```
客户端: NUMACONFIG SET strategy weighted

┌─────────────────────────────────────────────────────────────┐
│  1-3步与场景5相同（网络层、命令查找、命令处理）                │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  4. SET子命令处理                                             │
│  numa_config_command.c: 处理SET分支                          │
│  └──► 解析参数: ["strategy", "weighted"]                     │
│  └──► parse_strategy_name("weighted")                       │
│       └──► 返回NUMA_STRATEGY_CONFIG_WEIGHTED                 │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  5. 更新运行时配置                                            │
│  numa_configurable_strategy.c: numa_config_set_strategy()    │
│  └──► pthread_mutex_lock(&g_config_mutex)                   │
│  └──► g_runtime_state.config.strategy_type = WEIGHTED        │
│  └──► pthread_mutex_unlock(&g_config_mutex)                 │
│  └──► 返回C_OK                                              │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  6. 返回确认响应                                              │
│  numa_config_command.c: addReplyStatus(c, "OK")              │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  7. 后续内存分配生效                                          │
│  zmalloc.c: numa_alloc_with_size()                          │
│  └──► select_best_node(size)                                │
│       └──► 根据新策略选择节点                                 │
│           └──► 加权随机选择逻辑                              │
└─────────────────────────────────────────────────────────────┘
```

**配置更新特点**:
- 线程安全：使用互斥锁保护配置状态
- 即时生效：下次内存分配即使用新策略
- 零停机：无需重启服务

---

## 场景7: 策略执行与内存分配交互

```
场景: 使用加权策略进行内存分配

┌─────────────────────────────────────────────────────────────┐
│  1. 内存分配请求                                              │
│  zmalloc.c: zmalloc(1024)                                   │
│  └──► numa_alloc_with_size(1024)                            │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  2. 策略选择                                                  │
│  numa_configurable_strategy.c: select_best_node(1024)        │
│  └──► switch(g_runtime_state.config.strategy_type)          │
│       └──► case NUMA_STRATEGY_CONFIG_WEIGHTED:              │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  3. 加权选择算法                                              │
│  ├──► 计算总权重: sum(node_weights) = 100+80 = 180          │
│  ├──► 生成随机数: rand_r(&seed) % 180 = 125                 │
│  ├──► 累积权重查找:                                         │
│  │    Node 0: weight=100, cumulative=100 < 125 ❌           │
│  │    Node 1: weight=80,  cumulative=180 ≥ 125 ✅           │
│  └──► 选择Node 1                                             │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  4. 执行分配                                                  │
│  numa_pool.c: numa_pool_alloc(1040, 1, ...)                 │
│  └──► 在Node 1的内存池中分配                                 │
│  └──► 更新统计: allocation_counters[1]++                     │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  5. 返回用户指针                                              │
│  返回: user_ptr = raw_ptr + PREFIX_SIZE                     │
└─────────────────────────────────────────────────────────────┘
```

**策略执行性能**:
- 策略选择: O(1) 时间复杂度
- 加权算法: O(N) 时间复杂度（N为节点数）
- 整体开销: < 1μs（典型场景）

---

## 场景8: 自动负载均衡触发流程

```
场景: serverCron检测到负载不均衡并触发重新平衡

┌─────────────────────────────────────────────────────────────┐
│  1. 定时调度                                                  │
│  server.c: serverCron()                                     │
│  └──► run_with_period(REBALANCE_INTERVAL)                   │
│       └──► 每5秒执行一次                                     │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  2. 负载均衡检查                                              │
│  numa_configurable_strategy.c: numa_config_needs_rebalance() │
│  └──► for each node:                                        │
│       ├──► utilization = bytes_allocated[i] / total_memory   │
│       ├──► 计算利用率差异                                     │
│       └──► if (max_diff > balance_threshold): return 1      │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  3. 执行重新平衡                                              │
│  numa_configurable_strategy.c: numa_config_trigger_rebalance()│
│  └──► 获取当前统计信息                                        │
│  └──► 分析热点数据                                            │
│  └──► 触发迁移策略（调用Key迁移模块）                         │
│       └──► numa_migrate_single_key()                        │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  4. 迁移执行                                                  │
│  numa_key_migrate.c: 执行具体迁移                            │
│  └──► 分配新内存                                              │
│  └──► 复制数据                                                │
│  └──► 原子切换指针                                            │
│  └──► 释放旧内存                                              │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  5. 更新统计                                                  │
│  重置相关统计计数器                                           │
│  记录重新平衡事件                                             │
└─────────────────────────────────────────────────────────────┘
```

**自动平衡特点**:
- 周期性检查：默认5秒间隔
- 智能触发：基于配置阈值
- 渐进式调整：避免激进迁移
- 统计驱动：基于实际使用情况

---

## 调试与监控

### 统计信息获取

```c
/* 内存池统计 */
numa_pool_stats_t pool_stats;
numa_pool_get_stats(node_id, &pool_stats);

/* 迁移统计 */
numa_migrate_stats_t migrate_stats;
numa_migrate_get_stats(&migrate_stats);

/* zmalloc统计 */
size_t used_memory = zmalloc_used_memory();
```

### 日志输出

```c
/* 在关键位置添加日志 */
serverLog(LL_NOTICE, "NUMA allocation on node %d, size %zu", 
          numa_get_current_node(), size);
```

---

## 场景9: NUMA内存池P1优化流程

### P1优化前后对比

**优化前 (P0)**：
- 仅使用Bump Pointer分配
- 释放的内存无法重用
- 碎片率2.36

**优化后 (P1)**：
- Free List + Bump Pointer
- 释放的内存加入free list供重用
- Compact机制自动清理低利用率chunk
- 碎片率2.00

### 分配流程详解

```
场景: SET mykey (100字节数据)

┌─────────────────────────────────────────────────────────────┐
│  1. 应用层调用                                                 │
│  zmalloc(100) → numa_alloc_with_size(100)                │
└──────────────────────────┼───────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  2. 计算size_class                                           │
│  size=100 → size_class_idx=4 (128B级别)                  │
│  alloc_size = 100 + 16 (PREFIX) = 116                      │
└──────────────────────────┼───────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  3. 🆕 P1优化 - 检查Free List                            │
│  pool = &pool_ctx.node_pools[0].pools[4]                  │
│  pthread_mutex_lock(&pool->lock)                          │
│                                                             │
│  free_block = pool->free_list;                            │
│  if (free_block && free_block->size >= 116) {             │
│      // 找到合适的空闲块，重用它 ✅                       │
│      result = free_block->ptr;                            │
│      pool->free_list = free_block->next;                  │
│      free(free_block);                                    │
│      goto unlock_and_return;                              │
│  }                                                        │
└──────────────────────────┼───────────────────────────────────┘
                           │ Free List未命中
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  4. Bump Pointer分配                                       │
│  chunk = pool->chunks;                                    │
│  if (chunk->offset + 128 <= chunk->size) {                │
│      result = chunk->memory + chunk->offset;              │
│      chunk->offset += 128;                                │
│      chunk->used_bytes += 116; // 🆕 P1追踪利用率        │
│  }                                                        │
└──────────────────────────┼───────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  5. 返回结果                                                 │
│  pthread_mutex_unlock(&pool->lock)                        │
│  numa_init_prefix(result, 100, 1)                         │
│  return result + 16; // user_ptr                          │
└─────────────────────────────────────────────────────────────┘
```

### 释放流程详解

```
场景: DEL mykey (释放100字节内存)

┌─────────────────────────────────────────────────────────────┐
│  1. 应用层调用                                                 │
│  zfree(user_ptr) → numa_free_with_size(user_ptr)          │
└──────────────────────────┼───────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  2. 读取PREFIX信息                                           │
│  prefix = (numa_alloc_prefix_t*)(user_ptr - 16)          │
│  total_size = prefix->size = 100                          │
│  from_pool = prefix->from_pool = 1                        │
│  raw_ptr = user_ptr - 16                                  │
└──────────────────────────┼───────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  3. 🆕 P1优化 - 计算size_class                            │
│  aligned_size = (100 + 15) & ~15 = 112                    │
│  查表：112 <= 128 → size_class_idx = 4                   │
│  // 无需额外metadata，通过size计算                        │
└──────────────────────────┼───────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  4. 🆕 P1优化 - 创建Free Block                           │
│  free_block = malloc(sizeof(free_block_t));  // 16字节   │
│  free_block->ptr = raw_ptr;                               │
│  free_block->size = 112;                                  │
│  free_block->next = NULL;                                 │
└──────────────────────────┼───────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  5. 🆕 P1优化 - 加入Free List                            │
│  pool = &pool_ctx.node_pools[0].pools[4]                  │
│  pthread_mutex_lock(&pool->lock)                          │
│                                                             │
│  free_block->next = pool->free_list; // 头插法            │
│  pool->free_list = free_block;                            │
│                                                             │
│  pthread_mutex_unlock(&pool->lock)                        │
│  // 不立即释放内存，留在free list中供重用              │
└─────────────────────────────────────────────────────────────┘
```

### Compact流程详解

```
场景: serverCron定时检查 (每10秒)

┌─────────────────────────────────────────────────────────────┐
│  1. 定时触发                                                   │
│  server.c: serverCron()                                   │
│  └──► run_with_period(10000)                            │
│       └──► numa_pool_try_compact()                     │
└──────────────────────────┼───────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  2. 🆕 P1优化 - 清理Free List                            │
│  pthread_mutex_lock(&pool->lock)                          │
│                                                             │
│  // 统计free list长度                                       │
│  free_count = count_free_list(pool->free_list);           │
│                                                             │
│  if (free_count > 10) {                                   │
│      // 太多空闲块，清空free list                           │
│      while (pool->free_list) {                            │
│          next = pool->free_list->next;                    │
│          free(pool->free_list);                           │
│          pool->free_list = next;                          │
│      }                                                    │
│      compacted_count++;                                   │
│  }                                                        │
└──────────────────────────┼───────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  3. 🆕 P1优化 - 释放低利用率Chunk                      │
│  chunk = pool->chunks;                                    │
│  while (chunk) {                                          │
│      utilization = chunk->used_bytes / chunk->size;       │
│                                                             │
│      if (utilization < 0.3 && (1.0 - utilization) >= 0.5) {│
│          // 利用率<30% 且 空闲>50%                           │
│          numa_free(chunk->memory, chunk->size);           │
│          free(chunk);                                     │
│          compacted_count++;                               │
│      }                                                    │
│      chunk = chunk->next;                                 │
│  }                                                        │
│  pthread_mutex_unlock(&pool->lock)                        │
└──────────────────────────┼───────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  4. 记录日志                                                  │
│  if (compacted_count > 0) {                               │
│      serverLog(LL_VERBOSE,                                │
│          "NUMA pool compacted %d items", compacted_count);│
│  }                                                        │
│  return compacted_count;                                  │
└─────────────────────────────────────────────────────────────┘
```

### P1优化关键设计

| 特性 | 实现 | 效果 |
|------|------|------|
| **Free List** | pool级别管理 | 重用率20-40% |
| **Compact** | <30%利用率触发 | 减少空闲chunk |
| **16字节PREFIX** | 保持不变 | 无额外开销 |
| **动态Chunk** | 16/64/256KB | 减少碎片 |
| **周期检查** | 每10秒 | 平衡性能与响应 |

**性能改善**:
- 碎片率3.61→2.36(P0)→2.00(P1) - 总计降低45%
- 内存效率27%→43%(P0)→50%(P1) - 总计提升85%

**详细文档**: [01-numa-pool-P1-callchain.md](./01-numa-pool-P1-callchain.md)

