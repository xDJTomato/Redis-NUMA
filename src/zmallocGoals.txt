# Redis-CXL v0.0.1 
## 基本需求
    本项目的总目标是通过libNUMA改造Redis v6.2.21，使得其内存分配机制NUMA节点感知，实现冷热缓存的分层控制机制。
    以此为CXL服务器设备提供良好的支持。
    以下分阶段提出需求。
### Phase 1 LibNUMA适配
    改造zmalloc.c/zmalloc.h，在不改变对外接口的函数返回值的基础上实现NUMA支持，当前的设计思路为：
    1.在redis-server服务启动时，查询系统NUMA信息，维护一组元数据，如系统NUMA可用性，
    按照NUMA相对距离升序排列的一组节点数组等，并提供一个用户接口通过特定指令修改NUMA分配策略，
    在本阶段，我们首先指定默认策略为最近节点优先，其余策略留下空间，先不实现，供后续开发。
    2.通过libNUMA提供的能力重写zmalloc，使得当系统NUMA可用时，使用libNUMA代替malloc作最底层的
    内存分配行为，注意：必须在原有的接口中实现，使用NUMA状态值作为条件来选择zmalloc的具体行为。
### 注意事项
#### 环境要求
    本设备暂时只运行在Ubuntu系统，并只是用libc作为内存分配器，MAKEFILE中需要禁用其他的内存分配器
    Redis提供了两种策略来维护zmalloc分配内存的大小，一种是使用PREFIX_SIZE在指针前4字节维护大小，
    而在部分系统上则直接使用malloc的能力，两种zmalloc策略返回的指针意义不同
    已知libNUMA不具备查询已分配内存大小的能力，因此不论系统是否支持malloc_size，都需要完全实现PREFIX_SIZE的策略。
    ✅ NUMA信息查询：启动时自动检测系统NUMA信息
    ✅ 节点距离排序：使用numa_distance()获取距离矩阵并按升序排列
    ✅ 最近节点优先策略：基于redis-server进程CPU亲和性确定最近节点
    ✅ libnuma集成：使用libnuma代替malloc作为底层分配器
    ✅ PREFIX_SIZE策略：为libnuma实现了完整的内存大小跟踪
    ✅ 向后兼容：初始化过程中发现NUMA不可用时自动回退到标准分配器

# Redis-CXL v0.0.2
    ## 基本需求
    本项目的总目标是通过libNUMA改造Redis v6.2.21，使得其内存分配机制NUMA节点感知，实现冷热缓存的分层控制机制。
    以此为CXL服务器设备提供良好的支持。
    本阶段需求是，创建一个独立的迁移模块，尽可能使用封装好的zmalloc相关方法，使用libNUMA将对象从NODE A 迁移至NODE B。
    具体的实现如下：
    ┌─────────────────────────────────────────┐
    │           zmalloc.c                     │
    │  (NUMA分配器接口，PREFIX管理)            │
    ├─────────────────────────────────────────┤
    │  numa_zmalloc() → numa_pool_alloc()    │
    │  numa_zfree()   → numa_pool_free()     │
    └─────────────────────────────────────────┘
                    │
                    ▼
    ┌─────────────────────────────────────────┐
    │         numa_pool.c/h                   │
    │  (内存池管理，64KB chunk)                │
    └─────────────────────────────────────────┘

    ## Phase 2 迁移模块设计思路（讨论中）

    ### 设计目标
    1. 双模式触发：同时支持命令触发和后台自动迁移
    2. 负载均衡：自动平衡各NUMA节点内存池负载，最大化数据吞吐量
    3. 热度感知：利用PREFIX的7字节padding存储冷热信息，指导迁移决策

    ### PREFIX结构优化方案
    
    当前结构（16字节）：
    ```c
    typedef struct {
        size_t size;           // 8字节 - 分配的内存大小
        char from_pool;        // 1字节 - 是否来自内存池
        char padding[7];       // 7字节 - 未使用
    } numa_alloc_prefix_t;
    ```
    
    优化后结构（仍16字节）：
    ```c
    typedef struct {
        size_t size;           // 8字节 - 分配的内存大小
        uint8_t from_pool : 1; // 1 bit  - 是否来自内存池
        uint8_t hotness : 3;   // 3 bits - 热度等级 (0-7, 0=冷, 7=热)
        uint8_t flags : 4;     // 4 bits - 预留标志位
        // 其中：
        uint8_t node_id;       // 1字节 - 当前所在NUMA节点
        uint8_t access_count;  // 1字节 - 访问计数器（用于热度计算）
        uint16_t last_access;  // 2字节 - 最后访问时间戳
        uint32_t reserved;     // 4字节 - 预留扩展
    } numa_alloc_prefix_t;
    ```

    ### 迁移模块架构

    ```
    ┌─────────────────────────────────────────────────────────┐
    │                    Redis Server                          │
    ├─────────────────────────────────────────────────────────┤
    │  Command Layer          │    Background Thread           │
    │  - MIGRATE KEY          │    - 定期检查负载              │
    │  - MIGRATE DB           │    - 热度分析                  │
    │  - SHOW NUMA STATS      │    - 自动迁移决策              │
    └───────────┬─────────────┴──────────┬────────────────────┘
                │                        │
                ▼                        ▼
    ┌─────────────────────┐    ┌─────────────────────┐
    │   numa_migrate.c    │    │  numa_migrate_bg.c  │
    │  (迁移执行引擎)      │    │  (后台决策引擎)      │
    │  - 数据复制          │    │  - 负载监控          │
    │  - 指针更新          │    │  - 热度计算          │
    │  - 原子切换          │    │  - 迁移调度          │
    └──────────┬──────────┘    └──────────┬──────────┘
               │                          │
               └──────────┬───────────────┘
                          ▼
            ┌─────────────────────────────┐
            │        zmalloc.c            │
            │  - PREFIX元数据管理          │
            │  - 访问统计更新              │
            │  - 节点感知分配              │
            └─────────────┬───────────────┘
                          │
                          ▼
            ┌─────────────────────────────┐
            │       numa_pool.c           │
            │  - 节点粒度内存池            │
            │  - 统计信息收集              │
            └─────────────────────────────┘
    ```

    ### 核心机制设计

    #### 1. 热度追踪机制
    - 在zmalloc_size()中嵌入低开销的热度更新
    - access_count累计访问次数
    - 超过阈值时提升hotness等级
    - 定期衰减未访问数据的热度

    #### 2. 负载监控
    - 每个节点的内存使用率
    - 访问压力（访问次数/时间）
    - 内存池命中率

    #### 3. 迁移决策
    - 冷数据（hotness < threshold）从高负载节点迁出
    - 优先迁移到距离近、负载低的节点
    - 热数据保留在本地节点

    #### 4. 迁移执行
    - 在目标节点分配新内存（numa_zmalloc_onnode）
    - 复制数据
    - 更新Redis对象指针
    - 释放原内存

    ### 待决策问题
    1. 热度衰减策略：如何降低长时间未访问数据的热度？
    2. 迁移粒度：按key迁移还是按内存块迁移？
    3. 并发控制：迁移过程中如何处理读写请求？
    4. 负载指标：用什么指标衡量节点负载？
    5. 触发阈值：自动迁移的触发条件是什么？