# NUMA透明迁移方案设计

## 问题分析

### 原方案的问题

**sdsnuma的问题**：
1. 需要修改sds代码，侵入性强
2. 只支持String类型，其他类型（List/Hash/Set）仍需单独处理
3. 上层代码需要显式调用`sdsnuma*`函数，不透明

### 新方案目标

**完全透明的key级NUMA迁移**：
- 上层代码（sds, robj, dict等）**完全无感知**
- 无需修改现有数据结构
- 通过**线程本地存储**传递key上下文
- zmalloc自动选择正确的NUMA节点

## 核心设计

### 架构图

```
┌─────────────────────────────────────────────────────────────────┐
│                    Redis命令处理层                               │
│  ┌───────────────────────────────────────────────────────────┐ │
│  │  1. 解析命令获取key                                        │ │
│  │  2. numa_set_current_key(key)  ← 设置线程本地key           │ │
│  │  3. 执行命令（GET/SET/等）                                 │ │
│  │  4. numa_clear_current_key()  ← 清除线程本地key            │ │
│  └───────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                    数据操作层（sds, robj, dict）                 │
│                    完全无感知，使用标准zmalloc                   │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                    zmalloc分配器                                │
│  ┌───────────────────────────────────────────────────────────┐ │
│  │  numa_alloc_with_size():                                   │ │
│  │    1. node = numa_get_allocation_node()                    │ │
│  │       - 检查tls_current_key                               │ │
│  │       - 如果有，查询key的目标节点                          │ │
│  │       - 如果没有，使用默认节点                             │ │
│  │    2. 从该节点的内存池分配                                 │ │
│  └───────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                    NUMA内存池（每节点独立）                      │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐             │
│  │ 节点0内存池  │  │ 节点1内存池  │  │ 节点N内存池  │             │
│  │ (热数据)    │  │ (冷数据)    │  │             │             │
│  └─────────────┘  └─────────────┘  └─────────────┘             │
└─────────────────────────────────────────────────────────────────┘
```

### 关键机制

#### 1. 线程本地存储传递key

```c
/* zmalloc.c */
static __thread sds tls_current_key = NULL;

void numa_set_current_key(sds key) {
    tls_current_key = key;
}

void numa_clear_current_key(void) {
    tls_current_key = NULL;
}
```

#### 2. 动态节点选择

```c
int numa_get_allocation_node(void) {
    /* 如果有当前key，使用key的目标节点 */
    if (tls_current_key) {
        return numa_key_get_target_node(tls_current_key);
    }
    /* 否则使用默认节点 */
    return numa_ctx.current_node;
}
```

#### 3. 元数据管理

```c
/* 轻量级元数据，只记录目标节点 */
typedef struct numa_key_info {
    int target_node;           /* 目标NUMA节点 */
    uint32_t access_count;     /* 访问计数 */
    uint32_t flags;            /* 标志位 */
} numa_key_info_t;

/* 全局哈希表: key -> numa_key_info_t */
dict *key_meta;
```

## 迁移语义

### "迁移"的真正含义

**不是**移动已分配的内存，而是**改变后续分配的节点**：

```
初始状态：
  key "mykey" 绑定到节点0
  
执行 NUMA.BIND mykey 1：
  - 更新元数据: target_node = 1
  - 已分配的内存保持不变（下次访问时重新分配）
  
下次访问 mykey：
  - numa_set_current_key("mykey")
  - zmalloc发现target_node=1
  - 从节点1的内存池分配
  - 复制数据到新内存
  - 释放旧内存
```

### 为什么这样设计？

| 方案 | 优点 | 缺点 |
|------|------|------|
| **移动已分配内存** | 立即生效 | 需要遍历所有数据结构，复杂且危险 |
| **改变后续分配** | 简单安全 | 延迟生效，旧内存需要释放 |

**选择延迟生效方案的理由**：
1. **简单**：不需要遍历复杂的数据结构
2. **安全**：不修改正在使用的内存
3. **自然**：Redis的COW（Copy-On-Write）机制类似

## 使用方式

### 1. 绑定key到指定节点

```bash
# 将mykey绑定到节点1
127.0.0.1:6379> NUMA.BIND mykey 1
OK

# 后续对mykey的分配将在节点1进行
127.0.0.1:6379> SET mykey "hello"  # 数据分配到节点1
OK
```

### 2. 查看key位置

```bash
127.0.0.1:6379> NUMA.WHERE mykey
1) "target_node"
2) (integer) 1
3) "access_count"
4) (integer) 42
```

### 3. 记录访问（用于自动冷热迁移）

```bash
127.0.0.1:6379> NUMA.TOUCH mykey
OK
```

## 代码集成

### 在命令处理中集成

```c
/* 在processCommand或具体命令处理中 */
void processCommand(client *c) {
    /* 获取命令涉及的key */
    sds key = getKeyFromCommand(c);
    
    /* 设置当前key上下文 */
    if (key) {
        numa_set_current_key(key);
    }
    
    /* 执行命令 - 所有zmalloc自动使用正确的节点 */
    call(c, CMD_CALL_FULL);
    
    /* 清除key上下文 */
    numa_clear_current_key();
}
```

### 对现有代码的影响

**零影响**！现有代码无需修改：

```c
/* sds.c - 完全不变 */
sds sdsnewlen(const void *init, size_t initlen) {
    sh = s_malloc(hdrlen+initlen+1);  // 自动使用正确的NUMA节点
    ...
}

/* object.c - 完全不变 */
robj *createStringObject(const char *ptr, size_t len) {
    o->ptr = sdsnewlen(ptr, len);  // 自动使用正确的NUMA节点
    ...
}
```

## 优势对比

### 与原sdsnuma方案对比

| 特性 | sdsnuma方案 | 透明迁移方案 |
|------|-------------|--------------|
| 侵入性 | 高（修改sds） | 低（只改zmalloc） |
| 类型支持 | 仅String | 所有类型（自动） |
| 上层感知 | 需要显式调用 | 完全透明 |
| 维护成本 | 高 | 低 |
| 灵活性 | 低 | 高 |

### 与显式迁移方案对比

| 特性 | 显式迁移（numa_key_migrate） | 透明迁移 |
|------|------------------------------|----------|
| 迁移时机 | 立即执行 | 延迟到下次分配 |
| 实现复杂度 | 高（需处理各种类型） | 低（复用zmalloc） |
| 性能影响 | 立即产生 | 分摊到后续操作 |
| 原子性 | 难以保证 | 自然保证 |

## 实现状态

### 已完成

- [x] 线程本地存储机制
- [x] 动态节点选择
- [x] 轻量级元数据管理
- [x] 基础命令（BIND, UNBIND, WHERE, TOUCH）

### 待完成

- [ ] 多节点内存池（每个NUMA节点独立的内存池）
- [ ] 自动冷热迁移策略
- [ ] 访问频率统计
- [ ] 与Redis命令处理集成

## 文件清单

| 文件 | 说明 |
|------|------|
| `numa_transparent_migrate.h` | 透明迁移模块头文件 |
| `numa_transparent_migrate.c` | 核心实现 |
| `zmalloc.c/h` | 扩展支持动态节点选择 |

## 总结

**透明迁移方案的核心价值**：

1. **对上层完全透明**：sds、robj、dict等无需任何修改
2. **自动节点选择**：zmalloc根据当前key自动选择NUMA节点
3. **延迟迁移**：通过改变后续分配实现迁移，简单安全
4. **通用性**：支持所有数据类型，无需类型特定处理

这是实现Redis NUMA感知的**最优雅方案**，最小化代码侵入，最大化功能收益！
